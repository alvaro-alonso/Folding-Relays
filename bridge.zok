import "utils/pack/u32/pack128" as pack128;
import "utils/pack/bool/unpack128" as unpack128;
import "utils/casts/bool_128_to_u32_4" as bool_128_to_u32_4;
import "utils/casts/u32_to_field" as u32_to_field;
import "utils/casts/u32_to_bits" as u32_to_bits;
import "hashes/sha256/1024bitPadded.zok" as sha1024;
import "hashes/sha256/256bitPadded" as sha256;
from "./compute_merkle_root" import generateMerkleTree;
from "./utils" import bytesToBigEndian, packTarget, packMaxVariance, getBitLength;


// call with last field of block array
def validate_target(u32[8] epoch, u32[4] next_epoch_head) -> u32[4] {
    u32 time_head = bytesToBigEndian(epoch[2]);
    u32 time_tail = bytesToBigEndian(epoch[6]);

    u32[4] current_target = packTarget(bytesToBigEndian(epoch[3]));
    u32 time_delta = time_tail - time_head;
    u32 target_time_delta = 1209600; // 2016 * 600 (time interval of 10 minutes)
    field mut target = pack128(current_target) * u32_to_field(time_delta); // target_time_delta

    u32[4] encoded_target = packTarget(bytesToBigEndian(next_epoch_head[3]));
    field encoded_target_extended = pack128(encoded_target) * u32_to_field(target_time_delta);
    
    // The encoding of targets uses a floor function, the comparison of a calculated target may therefore fail
    // Therefore, a maximum variance is calculated that is one hex digit in the encoding
    bool[24] next_target = u32_to_bits((bytesToBigEndian(next_epoch_head[3]) << 8) >> 8)[8..32];
    u32 length = getBitLength(unpack128(target)) - getBitLength(next_target);
    field maxVariance = packMaxVariance(length);
    // int('ffff' + 10 * '00', 16) * 2016 * 600 = 95832923060582736897701037735936000
    target = if (target > 95832923060582736897701037735936000) { 95832923060582736897701037735936000 } else { target };
    field mut delta = target - encoded_target_extended;
    delta = if target >= encoded_target_extended { delta } else { maxVariance + 1 };
    
    assert(delta <= maxVariance);
    return current_target;
}


def validate_block_header(u32[4] reference_target, u32[8] prev_block_hash, u32[5][4] preimage) -> u32[8] {
    u32[4] a = preimage[0];
    u32[4] b = preimage[1];
    u32[4] c = preimage[2];
    u32[4] d = preimage[3];
    u32[4] e = preimage[4];

    u32[4] encoded_prev_block_hash1 = [...a[1..4], b[1]];
    u32[4] encoded_prev_block_hash2 = [...b[1..4], c[1]];
    assert(encoded_prev_block_hash1 == prev_block_hash[0..4] && encoded_prev_block_hash2 == prev_block_hash[4..8]);

    // converting to big endian is not necessary here, as reference target is encoded little endian
    u32[4] current_target = [0x00000000, 0x00000000, 0x00000000, e[3]];
    assert(current_target == reference_target);

    u32[8] preimage1 = [...a, ...b];
    u32[8] preimage2 = [...c, ...d];
    u32[8] preimage3 = [...e, ...bool_128_to_u32_4([true, ...[false;127]])];
    u32[8] dummy = [ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000280];

    u32[8] intermediary = sha1024(preimage1, preimage2, preimage3, dummy);
    u32[8] r = sha256(intermediary);

    field target = pack128(packTarget(bytesToBigEndian(e[3])));
    assert(target > pack128(r[4..8]));

    return r;
}

const u32 BLOCKS = 4;
const u32 TREE_DEPTH = 2;

def main(u32[4] first_block_epoch, u32[8] prev_block_hash, private u32[BLOCKS][5][4] intermediate_blocks, u32[5][4] final_block) -> (u32[12], field) {
   
    u32[BLOCKS][8] mut blocks = [[0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]; BLOCKS];
    u32[8] mut previous_block = prev_block_hash;

    for u32 i in 0..BLOCKS {
        blocks[i] = validate_block_header(first_block_epoch, previous_block, intermediate_blocks[i]);
        previous_block = blocks[i];
    }
    
    u32[4] e = final_block[4];
    u32[8] last_block = blocks[BLOCKS - 1];
    u32[8] final_block_hash = validate_block_header([0x00000000, 0x00000000, 0x00000000, e[2]], last_block, final_block);

    u32[4] current_target = validate_target([...first_block_epoch, ...intermediate_blocks[BLOCKS - 1][4]], final_block[4]);

    field merkle_root = generateMerkleTree(blocks, TREE_DEPTH);

    return ([ ...final_block_hash, ...current_target], merkle_root);
}

    