import "utils/pack/u32/pack128" as pack128;
import "utils/pack/bool/unpack128" as unpack128;
import "utils/casts/u32_to_field" as u32_to_field;
import "utils/casts/u32_to_bits" as u32_to_bits;
import "hashes/sha256/1024bit.zok" as sha1024;
import "hashes/sha256/512bit" as sha256;
from "./compute_merkle_root" import generateMerkleTree;
from "./utils" import bytesToBigEndian, packTarget, packMaxVariance, getBitLength, u32ArrayToBigEndian;


// call with last field of block array
def validate_target(u32[8] epoch, u32[4] next_epoch_head) -> u32[4] {
    u32 time_head = bytesToBigEndian(epoch[2]);
    u32 time_tail = bytesToBigEndian(epoch[6]);

    u32[4] current_target = packTarget(bytesToBigEndian(epoch[3]));
    u32 time_delta = time_tail - time_head;
    u32 target_time_delta = 1209600; // 2016 * 600 (time interval of 10 minutes)
    field mut target = pack128(current_target) * u32_to_field(time_delta); // target_time_delta

    u32[4] encoded_target = packTarget(bytesToBigEndian(next_epoch_head[3]));
    field encoded_target_extended = pack128(encoded_target) * u32_to_field(target_time_delta);
    
    // The encoding of targets uses a floor function, the comparison of a calculated target may therefore fail
    // Therefore, a maximum variance is calculated that is one hex digit in the encoding
    bool[24] next_target = u32_to_bits((bytesToBigEndian(next_epoch_head[3]) << 8) >> 8)[8..32];
    u32 length = getBitLength(unpack128(target)) - getBitLength(next_target);
    field maxVariance = packMaxVariance(length);
    // int('ffff' + 10 * '00', 16) * 2016 * 600 = 95832923060582736897701037735936000
    target = if (target > 95832923060582736897701037735936000) { 95832923060582736897701037735936000 } else { target };
    field mut delta = target - encoded_target_extended;
    delta = if target >= encoded_target_extended { delta } else { maxVariance + 1 };
    
    assert(delta <= maxVariance);
    return current_target;
}

def validate_block_header(u32[4] reference_target, u32[8] prev_block_hash, u32[5][4] preimage) -> u32[8] {
    u32[4] a = preimage[0];
    u32[4] b = preimage[1];
    u32[4] c = preimage[2];
    u32[4] d = preimage[3];
    u32[4] e = preimage[4];

    // ensure the previous calculated hash matches the `previous_hash` of the current block header
    u32[8] encoded_prev_block_hash = [...a[1..4], ...b[0..4], c[0]];
    assert(encoded_prev_block_hash == prev_block_hash);

    // converting to big endian is not necessary here, as reference target is encoded little endian
    u32[4] current_target = [...[0x00000000; 3], e[2]];
    assert(current_target == reference_target);

    // first hash, block header
    u32[8] preimage1 = [...a, ...b];
    u32[8] preimage2 = [...c, ...d];
    u32[8] preimage3 = [...e, ...[0x80000000, ...[0x00000000; 3]]];
    u32[8] mut padding = [...[0x00000000; 7], 0x00000280];
    u32[8] intermediary = sha1024(preimage1, preimage2, preimage3, padding);
    
    // second hash round
    padding = [0x80000000, ...[0x00000000; 6], 0x00000100];
    u32[8] r = sha256(intermediary, padding);
    
    field target = pack128(packTarget(bytesToBigEndian(e[2])));
    field r_var = pack128(u32ArrayToBigEndian(r[4..8]));
    assert(target > r_var);

    return r;
}


const u32 TREE_DEPTH = 1;
const u32 BLOCKS = 2 ** TREE_DEPTH;

def main(u32[4] first_block_epoch, u32[8] prev_block_hash, private u32[BLOCKS][5][4] headers) -> u32[12] {
   
    u32[BLOCKS][8] mut blocks = [[0x00000000; 8]; BLOCKS];
    u32[8] mut previous_block = prev_block_hash;

    for u32 i in 0..BLOCKS {
        blocks[i] = validate_block_header([...[0x00000000; 3], headers[i][4][2]], previous_block, headers[i]);
        previous_block = blocks[i];
        log("Block Nr.{} correctly validated!", i);
    }

    // TODO: until here is working!

    u32[4] current_target = validate_target([...first_block_epoch, ...headers[BLOCKS - 2][4]], headers[BLOCKS - 1][4]);

    // field merkle_root = generateMerkleTree(blocks, TREE_DEPTH);

    return [ ...blocks[BLOCKS - 1], ...current_target]; // , merkle_root);
}

    