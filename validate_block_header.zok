import "utils/casts/bool_128_to_u32_4" as bool_128_to_u32_4;
import "utils/casts/u32_from_bits" as u32_from_bits;
import "utils/casts/u8_to_bits" as u8_to_bits;
import "utils/casts/u8_from_bits" as u8_from_bits;
import "utils/pack/u32/pack128" as pack128;
import "hashes/sha256/1024bitPadded.zok" as sha256for1024;
import "hashes/sha256/256bitPadded" as sha256for256;
from "./utils" import bytesToBigEndian, packTarget;



def main(u32[4] reference_target, u32[8] prev_block_hash, u32[5][4] preimage) -> u32[8] {
    u32[4] a = preimage[0];
    u32[4] b = preimage[1];
    u32[4] c = preimage[2];
    u32[4] d = preimage[3];
    u32[4] e = preimage[4];

    u32[4] encoded_prev_block_hash1 = [...a[1..4], b[1]];
    u32[4] encoded_prev_block_hash2 = [...b[1..4], c[1]];
    assert(encoded_prev_block_hash1 == prev_block_hash[0..4] && encoded_prev_block_hash2 == prev_block_hash[4..8]);

    // converting to big endian is not necessary here, as reference target is encoded little endian
    u32[4] current_target = [0x00000000, 0x00000000, 0x00000000, e[3]];
    assert(current_target == reference_target);

    u32[8] preimage1 = [...a, ...b];
    u32[8] preimage2 = [...c, ...d];
    u32[8] preimage3 = [...e, ...bool_128_to_u32_4([true, ...[false;127]])];
    u32[8] dummy = [ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000280];

    u32[8] intermediary = sha256for1024(preimage1, preimage2, preimage3, dummy);
    u32[8] r = sha256for256(intermediary);

    field target = pack128(packTarget(bytesToBigEndian(e[3])));
    assert(target > pack128(r[4..8]));

    return r;
}